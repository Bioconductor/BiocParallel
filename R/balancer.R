## Find the balancer generator function given the name or the function
.findBalancer <-
    function(type = c("lapply", "iterate"), balancer = NULL)
{
    type <- match.arg(type)
    if (is.null(balancer))
        balancer = "sequential"

    if (is.character(balancer)) {
        if (type == "lapply") {
            if (balancer == "sequential")
                return(.lapplySequentialBalancer)
            if (balancer == "random")
                return(.lapplyRandomBalancer)
        } else {
            if (balancer == "sequential")
                return(.iterateSequentialBalancer)
        }
    }

    if (is.function(balancer))
        return(balancer)
    stop("Unrecognized balancer")
}



##################
## bplapply balancer generator:
## Input:
##  1. X: The variable that will be looped over by bplapply
##  2. BPPARAM: The parallel backend, you should respect the value
##      bptasks(BPPARAM) as much as possible
## Output: a list with two functions
##  1. nextTask(): The next Task, the return value is a list with
##      - task_id: An arbitrary index used by the balancer to identify the task
##      - value: A subset of X
##      - index: The index of the subset of X in the original position
##               (The index must be increasing!)
##  2. record(worker, task_id, time): record the task execution time in seconds
##     argument:
##      - worker: which worker is responsible for this task
##      - task_id: The id generated by nextTask()
##      - time: The execution time in seconds
##################

## A simple balancer to equally divide the vector X into tasks.
.lapplySequentialBalancer <- function(X, BPPARAM) {
    force(X)
    ## How many elements in a task?
    ntask <- .ntask(X, bpnworkers(BPPARAM), bptasks(BPPARAM))
    elements_per_task <- ceiling(length(X)/ntask)
    task_id <- 0L
    index <- 1L
    list(
        record = function(node, task_id, time) {
            # message("Node:", node, ",id:", task_id, ",time:", time)
        },
        nextTask = function(){
            upper <- min(length(X), index + elements_per_task - 1L)
            subscript <- seq.int(index, upper)
            index <<- index + length(subscript)
            task_id <<- task_id + 1L
            list(
                task_id = task_id,
                index = subscript,
                value = X[subscript]
            )
        }
    )
}

## Randomly sample the vector X.
.lapplyRandomBalancer <- function(X, BPPARAM) {
    force(X)
    ## How many elements in a task?
    ntask <- .ntask(X, bpnworkers(BPPARAM), bptasks(BPPARAM))
    elements_per_task <- ceiling(length(X)/ntask)
    randomIndex <- sample.int(length(X))
    task_id <- 0L
    index <- 1L
    list(
        record = function(node, task_id, time) {
            # message("Node:", node, ",id:", task_id, ",time:", time)
        },
        nextTask = function(){
            upper <- min(length(X), index + elements_per_task - 1L)
            subscript <- sort(randomIndex[seq.int(index, upper)])
            index <<- index + length(subscript)
            task_id <<- task_id + 1L
            list(
                task_id = task_id,
                index = subscript,
                value = X[subscript]
            )
        }
    )
}

.iterateSequentialBalancer <-
    function(ITER, BPPARAM)
{
    force(ITER)
    task_id <- 0L
    list(
        record = function(node, task_id, time) {
            # message("Node:", node, ",id:", task_id, ",time:", time)
        },
        nextTask = function(){
            task_id <<- task_id + 1L
            list(
                task_id = task_id,
                index = task_id,
                value = list(ITER())
            )
        }
    )
}
